/*
Copyright (C) 2023 The Falco Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

package data

// NOTE: Since most subpackages of the "tests" package depend on the
// generation of files under "tests/data", we always need to make sure that
// "go generate" generates "tests/data" first. "go generate" follows the
// same order of packages as the one of "go list". For now we are good because
// "tests/data" is always generated before "tests/falco", "tests/falcoctl", etc,
// but we need to be mindful of this in the future.

import (
	"archive/zip"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"path"
	"path/filepath"
	"strings"
	"text/template"
	"time"

	"github.com/iancoleman/strcase"
	"github.com/sirupsen/logrus"
)

const (
	// FalcoCodeVersion is a git tag used to pull the code of
	// falcosecurity/falco and extract the test data files used in the
	// legacy Python regression tests
	FalcoCodeVersion = "0.34.1"
	FalcoCodeDir     = "falco-" + FalcoCodeVersion
)

var (
	DownloadDir  = ""
	FalcoCodeURL = fmt.Sprintf("https://github.com/falcosecurity/falco/archive/refs/tags/%s.zip", FalcoCodeVersion)
)

func init() {
	var err error
	DownloadDir, err = filepath.Abs("../../../build/data")
	if err != nil {
		log.Fatal(err.Error())
	}
}

type LargeFileVarInfo struct {
	VarName  string
	FileName string
	FilePath string
}

type StringFileVarInfo struct {
	VarName     string
	FileName    string
	FileContent string
}

type GenTemplateInfo struct {
	Timestamp   time.Time
	PackageName string
	LargeFiles  []*LargeFileVarInfo
	StringFiles []*StringFileVarInfo
}

var genTemplate = template.Must(template.New("getTemplate").Parse(
	`// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at {{ .Timestamp }}

package {{ .PackageName }}

import (
	"github.com/falcosecurity/testing/pkg/run"
)
{{range $idx, $info := .StringFiles}}
var {{ .VarName }} = run.NewStringFileAccessor(
	"{{ .FileName }}",
	` + "`" + `{{ .FileContent }}` + "`" + `,
)
{{end}}{{range $idx, $info := .LargeFiles}}
var {{ .VarName }} = run.NewLocalFileAccessor(
	"{{ .FileName }}",
	"{{ .FilePath }}",
)
{{end}}
`))

func GenSourceFile(w io.Writer, info *GenTemplateInfo) error {
	return genTemplate.Execute(w, info)
}

func Download(url, outPath string) error {
	if _, err := os.Stat(outPath); err == nil {
		logrus.Infof("skipping download of %s, %s is already present", url, outPath)
		return nil
	}
	logrus.Infof("creating dir %s", filepath.Base(outPath))
	err := os.MkdirAll(filepath.Dir(outPath), os.ModePerm)
	if err != nil {
		return err
	}
	logrus.Infof("downloading %s into %s", url, outPath)
	resp, err := http.Get(url)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	file, err := os.Create(outPath)
	if err != nil {
		return err
	}
	defer file.Close()
	_, err = io.Copy(file, resp.Body)
	if err != nil {
		return err
	}
	return nil
}

func Unzip(zipFile, outDir string) error {
	logrus.Infof("unzipping %s into dir %s", zipFile, outDir)
	reader, err := zip.OpenReader(zipFile)
	if err != nil {
		return err
	}
	defer reader.Close()

	for _, file := range reader.File {
		relname := path.Join(outDir, file.Name)
		if _, err := os.Stat(relname); err == nil {
			logrus.Infof("skipping extraction of %s as it is already present", relname)
			continue
		}

		logrus.Debugf("extracting %s", relname)
		fileReader, err := file.Open()
		if err != nil {
			return err
		}
		defer fileReader.Close()
		if file.FileInfo().IsDir() {
			err = os.MkdirAll(relname, os.ModePerm)
			if err != nil {
				return err
			}
		} else {
			err = os.MkdirAll(path.Dir(relname), os.ModePerm)
			if err != nil {
				return err
			}
			out, err := os.Create(relname)
			if err != nil {
				return err
			}
			defer out.Close()
			_, err = io.Copy(out, fileReader)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func ListDirFiles(dirPath string, recursive bool) ([]string, error) {
	if !strings.HasSuffix(dirPath, "/") {
		dirPath += "/"
	}

	var res []string
	files, err := os.ReadDir(dirPath)
	if err != nil {
		return nil, err
	}
	for _, file := range files {
		fileName := dirPath + file.Name()
		if file.IsDir() {
			if recursive {
				subres, err := ListDirFiles(fileName+"/", recursive)
				if err != nil {
					return nil, err
				}
				res = append(res, subres...)
			}
			continue
		}
		res = append(res, fileName)
	}
	return res, nil
}

func DownloadAndListFalcoCodeFiles() ([]string, error) {
	extractDir := DownloadDir
	err := Download(FalcoCodeURL, DownloadDir+"/"+FalcoCodeDir+".zip")
	if err != nil {
		return nil, err
	}
	err = Unzip(DownloadDir+"/"+FalcoCodeDir+".zip", extractDir)
	if err != nil {
		return nil, err
	}
	return ListDirFiles(extractDir+"/"+FalcoCodeDir+"/", true)
}

func VarNameFromFilePath(path, prefix string) string {
	path = strings.TrimPrefix(path, prefix)
	path = strings.TrimSuffix(path, filepath.Ext(filepath.Base(path)))
	path = strings.ReplaceAll(path, "/", "_")
	return strcase.ToCamel(path)
}
